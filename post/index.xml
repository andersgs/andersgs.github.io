<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on dsci&#39;nomics: data science with a side of genomics</title>
    <link>/post/</link>
    <description>Recent content in Posts on dsci&#39;nomics: data science with a side of genomics</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Anders Gon√ßalves da Silva</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A first taste of the common workflow language, part 1.</title>
      <link>/post/2017-05-07-taste-of-cwl-part1/</link>
      <pubDate>Sun, 07 May 2017 12:00:00 +0000</pubDate>
      
      <guid>/post/2017-05-07-taste-of-cwl-part1/</guid>
      <description>

&lt;h1 id=&#34;some-motivation&#34;&gt;Some motivation&amp;hellip;&lt;/h1&gt;

&lt;p&gt;In a few days, I&amp;rsquo;ll be attending a workshop on the
&lt;a href=&#34;(http://www.commonwl.org/)&#34; target=&#34;_blank&#34;&gt;Common Workflow Language&lt;/a&gt;, organised by the
great folks at &lt;a href=&#34;http://www.melbournebioinformatics.org.au&#34; target=&#34;_blank&#34;&gt;Melbourne Bioinformatics&lt;/a&gt;,
and to be run by one of CWL&amp;rsquo;s principal developers, Michael Crusoe
(&lt;a href=&#34;https://twitter.com/biocrusoe&#34; target=&#34;_blank&#34;&gt;@biocrusoe&lt;/a&gt;). In preparation for the workshop
I thought I would write a series of three posts to outline a bit of my
experience with CWL, and get all my questions for Michael ready!&lt;/p&gt;

&lt;h1 id=&#34;outline&#34;&gt;Outline&lt;/h1&gt;

&lt;p&gt;In this first post, I&amp;rsquo;ll give a quick outline of why I got excited about
CWL, and introduce the &lt;code&gt;Command Line Tool Description&lt;/code&gt;, the one of two
documents you can write with CWL. In the second post, I&amp;rsquo;ll go over the
&lt;code&gt;Workflow Description&lt;/code&gt; document, and then in the third post, I&amp;rsquo;ll
wrap up by giving a quick overview of the tools available to run
CWL flows, and finish with my list of what I really like
about CWL and what I think was not quite as intuitive as I had hoped.&lt;/p&gt;

&lt;h1 id=&#34;getting-excited-about-cwl&#34;&gt;Getting excited about CWL&lt;/h1&gt;

&lt;p&gt;If you go to the CWL webpage you are greeted, right at the top, by these two
sentences:&lt;/p&gt;

&lt;div class=&#34;alert alert-success&#34;&gt;
  &lt;p&gt;The Common Workflow Language (CWL) is a specification for describing analysis workflows and tools in a way that makes them portable and scalable across a variety of software and hardware environments, from workstations to cluster, cloud, and high performance computing (HPC) environments. CWL is designed to meet the needs of data-intensive science, such as Bioinformatics, Medical Imaging, Astronomy, Physics, and Chemistry.&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;When I first read that a couple of months ago, I found it hard not to get
very excited with these promises. The idea of
writing a single workflow that can be easily scaled up from a single
machine to the cloud, and beyond, is very appealing! &lt;code&gt;And, it supports Docker
containers!&lt;/code&gt;. I then decided to try it out
with a real problem that I had at the time: I needed to estimate limit of
detection of &lt;em&gt;in silico&lt;/em&gt; MLST for NATA accreditation. At MDU, we use
Torsten Seemann&amp;rsquo;s (&lt;a href=&#34;https://thegenomefactory.blogspot.com.au/&#34; target=&#34;_blank&#34;&gt;The Genome Factory&lt;/a&gt;)
&lt;a href=&#34;https://github.com/tseemann/mlst&#34; target=&#34;_blank&#34;&gt;MLST&lt;/a&gt; program, which requires an assembly.
My workflow would then consist of taking PE reads as input, sub-sampling
them to a certain depth of coverage, assembling, running MLST, and collating
the data into a single table to be easily imported into &lt;code&gt;R&lt;/code&gt;. Simple, right?
Almost, there were a few hitches along the way, but I was still impressed
with CWL.&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;p&gt;One important thing to remember: CWL is the spec! It is designed to be &lt;code&gt;vendor&lt;/code&gt;
agnostic (a &lt;em&gt;lingua franca&lt;/em&gt; or trading language for workflows). So, it is
important to distinguish between perceived CWL shortcomings, and
shortcomings of any particular &lt;code&gt;vendor&lt;/code&gt; that advertises CWL-support.&lt;/p&gt;

&lt;/div&gt;


&lt;h1 id=&#34;the-cwl-basics&#34;&gt;The CWL basics&lt;/h1&gt;

&lt;p&gt;Given my experience with &lt;code&gt;make&lt;/code&gt; I made the mistake of making comparisons with it,
and had the wrong expectations.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
  &lt;p&gt;My advise is, if you have used &lt;code&gt;make&lt;/code&gt;, keep an open mind while delving into CWL.
While there are some similarities, implementation differs.&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;The general idea of CWL is that you write your workflow as a YAML or JSON
file. These files can then be read and executed by any number of
different software (called &lt;code&gt;vendors&lt;/code&gt;). That is what makes CWL portable.
It provides a set of rules of how to write these YAML files that
can be expected to be respected by any piece of software that claims to
support CWL.&lt;/p&gt;

&lt;p&gt;There are two kind of documents you can write: &lt;code&gt;Command Line Tool
Description&lt;/code&gt;, and a &lt;code&gt;Workflow Description&lt;/code&gt;. The &lt;code&gt;Command Line Tool 
Description&lt;/code&gt;, as the name implies, describes how to build
command lines, which are the building blocks of for the &lt;code&gt;Workflow
Description&lt;/code&gt; documents. In this post, we will look
over &lt;code&gt;Command Line Tool Description&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;an-example-command-line-tool-description&#34;&gt;An example Command Line Tool Description&lt;/h2&gt;

&lt;p&gt;The first step of my limit of detection pipeline was to sub-sample reads
from a pair of FASTQ files. In this post, and the next, I will show you
how I did this in &lt;code&gt;CWL&lt;/code&gt; using Heng Li&amp;rsquo;s &lt;code&gt;seqtk&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Command Line Tool Description&lt;/code&gt; is a YAML document that describes how
to build a command line string to run a certain command, and what to do
with the output of the command. To get started, let us have a look a the
description for &lt;code&gt;seqtk sample&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage:   seqtk sample [-2] [-s seed=11] &amp;lt;in.fa&amp;gt; &amp;lt;frac&amp;gt;|&amp;lt;number&amp;gt;

Options: -s INT       RNG seed [11]
         -2           2-pass mode: twice as slow but with much reduced memory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By this description, &lt;code&gt;seqtk sample&lt;/code&gt; needs an input sequence file (that while
is implied to be FASTA, it will also accept FASTQ); a fraction or number of
reads to keep (in my case, I used number of reads); and it can optionally
take a &lt;code&gt;seed&lt;/code&gt; to set the random number generator, and a flag to indicate
whether to use a &lt;code&gt;2-pass mode&lt;/code&gt; or not. I chose not to use the &lt;code&gt;2-pass mode&lt;/code&gt;,
so will ignore that option below. However, the &lt;code&gt;seed&lt;/code&gt; option was essential
to work with PE reads. By giving the pair of sequences the same seed, I
can guarantee that the same sequenced fragments will be selected from the
two files. What is not explicit in the description is that the output is
streamed to &lt;code&gt;stdout&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, I am looking to build the equivalent of:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;seqtk sample -s 6773 seq_R1.fq 1000 &amp;gt; seq_10000_R1.fq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is how we achieve it using the CLI tool description in CWL (below
I go over each line in detail):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cwlVersion: v1.0
class: CommandLineTool
doc: &amp;gt;
  A command line tool to use seqtk sample to sub-sample N reads from a single
  FASTQ file. The use of the seed ensures that pairs of reads have the same
  records sampled, and ensure reproducibility of the pipeline by others.
baseCommand: [&#39;seqtk&#39;, &#39;sample&#39;]
inputs:
    seed:
        type: int
        inputBinding:
            prefix: -s
            position: 1
        doc: The seed needed to ensure the same records are kept across PE files
    fastq:
        type: File
        inputBinding:
            position: 2
        doc: A single FASTQ input file
    number:
        type: int
        inputBinding:
            position: 3
        doc: An integer specifying how many records to keep
    seqid: 
        type: string
        doc: &amp;gt;
          A string to be used in the output name (notice no inputBinding) to 
          indicate the ID of the sample.
    read_number: 
        type: int
        doc: &amp;gt;
          An int to be used in the output name (notice no inputBinding) that 
          indicates if it is READ1 or READ2 in a pair
    rep: 
        type: int
        doc: &amp;gt;
          An int to be used in the output name (notice no inputBinding) to 
          indicate the replicate sub-sample number
outputs:
    seqtkout:
        type: stdout
stdout: $(inputs.seqid)___$(inputs.number)-$(inputs.seed)-$(inputs.rep)___R$(inputs.read_number).fq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first two lines are self-evident. You must specify the version of the
CWL specification that you are using, and that this document specifies a
&lt;code&gt;Command Line Tool&lt;/code&gt;. The &lt;code&gt;baseCommand&lt;/code&gt; specifies the executable that
should be called, in this case I gave it an array with the main executable
(&lt;code&gt;seqtk&lt;/code&gt;), and the sub-command (&lt;code&gt;sample&lt;/code&gt;). But, a single string with a
command can be used when appropriate (e.g., &lt;code&gt;baseCommand: mlst&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;doc&lt;/code&gt; strings can be used throughout the document to describe what you are
doing and why! I really like this feature, but I suspect it will seldom be
actually used, which is a pity.&lt;/p&gt;

&lt;p&gt;Next I have listed the inputs to the tool under &lt;code&gt;inputs&lt;/code&gt;.
In &lt;code&gt;inputs&lt;/code&gt;, you can list each input the command-line tool requires, and under
each input, you need to specify the &lt;code&gt;type&lt;/code&gt;, in this case there are two
examples &lt;code&gt;File&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;. Other types include &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;array&lt;/code&gt;,
&lt;code&gt;Directory&lt;/code&gt;, or custom types, which I&amp;rsquo;ll demonstrate in the next post.&lt;/p&gt;

&lt;p&gt;For those inputs that will be used to form the command string that will
be run, you must specify the &lt;code&gt;inputBindings&lt;/code&gt;. These describe any
&lt;code&gt;prefixes&lt;/code&gt; the option should have while building the command string,
the position of each option, if there should be a space between the &lt;code&gt;prefix&lt;/code&gt;
and the &lt;code&gt;value&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;outputs&lt;/code&gt; section works in a similar way. The name of a particular input
here could be used as an &lt;code&gt;input&lt;/code&gt; in another tool downstream. This helps setup
&lt;code&gt;make&lt;/code&gt;-like dependencies among tools in a pipeline. One cool thing about &lt;code&gt;CWL&lt;/code&gt;
is that it is able to capture &lt;code&gt;stdout&lt;/code&gt; of a tool, and push it to a file.&lt;/p&gt;

&lt;p&gt;If capturing the tools &lt;code&gt;stdout&lt;/code&gt;, you need to specify a filename
under the &lt;code&gt;stdout&lt;/code&gt; key. This could be a simple string (e.g., &lt;code&gt;myout.txt&lt;/code&gt;),
or it can be an expression, as I have used here. In this case, I used the
&lt;code&gt;$()&lt;/code&gt; notation to access elements of the &lt;code&gt;inputs&lt;/code&gt; object. The &lt;code&gt;$()&lt;/code&gt; gives you
access to a limited set of JavaScript notation to access different objects.
You can use it to access data in &lt;code&gt;inputs&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, and &lt;code&gt;runtime&lt;/code&gt; objects.
In this case, I use it to create a filename that has the following pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mySeqId___1000-899666-3___R1.fq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The values for each parameter are listed under the &lt;code&gt;inputs&lt;/code&gt; section!&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
  &lt;p&gt;CWL lets you use a &lt;code&gt;$()&lt;/code&gt; to access parameter values within different
objects. Check out the
&lt;a href=&#34;http://www.commonwl.org/v1.0/Workflow.html&#34; target=&#34;_blank&#34;&gt;documentation&lt;/a&gt; for description
of the objects you can access automatically.&lt;/p&gt;

&lt;/div&gt;


&lt;h1 id=&#34;that-is-it-for-now&#34;&gt;That is it for now&amp;hellip;&lt;/h1&gt;

&lt;p&gt;That is all you really need to know to get started writing your own
&lt;code&gt;Command Line Tool Descriptions&lt;/code&gt;. It is fairly simple, and I fount it to be
highly readable. If you want some more examples, check out the
&lt;a href=&#34;http://www.commonwl.org/v1.0/UserGuide.html#Wrapping_Command_Line_Tools&#34; target=&#34;_blank&#34;&gt;Wrapping Command Line Tools&lt;/a&gt;
section of the Gentle Introduction to CWL.&lt;/p&gt;

&lt;p&gt;As I said before, in part 2 of this post I&amp;rsquo;ll go over the basic
of writing a &lt;code&gt;Workflow Description&lt;/code&gt; to produce untold number of
sub-sampled reads that use the above CLI description as a building
block.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R upgrading can be a smooth process</title>
      <link>/post/2017-04-28-upgrade-to-r-3-4-0/</link>
      <pubDate>Fri, 28 Apr 2017 12:00:00 +0000</pubDate>
      
      <guid>/post/2017-04-28-upgrade-to-r-3-4-0/</guid>
      <description>

&lt;h1 id=&#34;the-problem&#34;&gt;The problem&lt;/h1&gt;

&lt;p&gt;A new version of &lt;code&gt;R&lt;/code&gt; is out &amp;mdash; &lt;a href=&#34;https://cran.r-project.org/doc/manuals/r-release/NEWS.html&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;You Stupid Darkness!&amp;rdquo;&lt;/a&gt;.
If you feel a mixture of dread and excitement about upgrading &lt;code&gt;R&lt;/code&gt; you
came to the right place. Upgrading &lt;code&gt;R&lt;/code&gt; can be exciting, usually because of new features!
In this latest version, I am particularly excited about this one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The JIT (‚ÄòJust In Time‚Äô) byte-code compiler is now enabled by default at its level 3. This means functions will be compiled on first or second use and top-level loops will be compiled and then run. (Thanks to Tomas Kalibera for extensive work to make this possible.)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, it did not disappoint. &lt;code&gt;R&lt;/code&gt; definitely feels snappier!&lt;/p&gt;

&lt;p&gt;However, upgrading &lt;code&gt;R&lt;/code&gt; can be a pain! Mostly because you may find yourself without any of
your beloved packages installed! If you are like me, however, you may already have
your packages installed in a central location outside the &lt;code&gt;R&lt;/code&gt; install folders. The
problem then becomes, how do I update/upgrade all my packages to make sure they
work nicely with the new version of &lt;code&gt;R&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-success&#34;&gt;
  &lt;p&gt;In this post I will cover:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;How to setup your own static &lt;code&gt;R&lt;/code&gt; library folder&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update to latest &lt;code&gt;R&lt;/code&gt; version with all your packages intact&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;/div&gt;


&lt;h1 id=&#34;some-initial-setup&#34;&gt;Some initial setup&lt;/h1&gt;

&lt;p&gt;By default, when you install a library, &lt;code&gt;R&lt;/code&gt; will install it on the top entry in
your &lt;code&gt;libPaths&lt;/code&gt;, a character vector holding the absolute paths to folders in your
system where libraries are stored. When you ask to load a library, &lt;code&gt;R&lt;/code&gt; will search
within these folders.&lt;/p&gt;

&lt;p&gt;You can see a list of these folders by typing the following in the &lt;code&gt;R&lt;/code&gt; console:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;.libPaths()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On a Mac, by default, this will return two paths (Linux will give you something
similar):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;&amp;quot;$HOME/Library/R/&amp;lt;R_version&amp;gt;/library&amp;quot;
&amp;quot;/Library/Frameworks/R.framework/Versions/&amp;lt;R_version&amp;gt;/Resources/library&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the paths depend on the &lt;code&gt;R&lt;/code&gt; version! So, these paths will change
every time you upgrade &lt;code&gt;R&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;&lt;strong&gt;Our goal is to make sure that the first path on that list is something that
does not change with every update of &lt;code&gt;R&lt;/code&gt;!&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;Let us start with the case where you don&amp;rsquo;t have your packages yet centrally
filed into a folder outside of the &lt;code&gt;R&lt;/code&gt; install folder. In my case, I have a
folder called &lt;code&gt;~/Rlibs&lt;/code&gt; where I keep my packages. But it can be called anything
you like. The trick is, once you have created the folder, to make sure it becomes
your default library install folder. To do that, copy paste the following commands
in to the &lt;code&gt;Terminal&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir ~/Rlibs
touch ~/.Renviron
echo &amp;quot;R_LIBS=~/Rlibs&amp;quot; &amp;gt; ~/.Renviron
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;.Renviron&lt;/code&gt; file is read by &lt;code&gt;R&lt;/code&gt; every time you start &lt;code&gt;R&lt;/code&gt;. It reads environmental
variables, in this case &lt;code&gt;R_LIBS&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, when you call &lt;code&gt;.libPaths()&lt;/code&gt; in the &lt;code&gt;R&lt;/code&gt; console, you should see the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;&amp;quot;$HOME/Rlibs&amp;quot;
&amp;quot;$HOME/Library/R/&amp;lt;R_version&amp;gt;/library&amp;quot;
&amp;quot;/Library/Frameworks/R.framework/Versions/&amp;lt;R_version&amp;gt;/Resources/library&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;preparing-for-the-upgrade&#34;&gt;Preparing for the upgrade&lt;/h1&gt;

&lt;h2 id=&#34;if-you-just-setup-your-rlibs-folder&#34;&gt;If you just setup your &lt;code&gt;Rlibs&lt;/code&gt; folder&lt;/h2&gt;

&lt;p&gt;If you just created your &lt;code&gt;Rlibs&lt;/code&gt; folder, it will be empty. So, before you upgrade,
you should create a list of packages that are currently installed so you can
install them again, now in your newly minted &lt;code&gt;Rlibs&lt;/code&gt; folder, once the upgrade
is complete.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;R&lt;/code&gt; console, type the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(magrittr)
library(readr)
installed.packages() %&amp;gt;% 
  as.data.frame() %&amp;gt;% 
  readr::write_csv(&amp;quot;/tmp/installed_packages.csv&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What this will do is create a file called &lt;code&gt;/tmp/installed_packages.csv&lt;/code&gt;. You can
put it someplace else, if you would like to keep for a posterity. I would just
dump it into &lt;code&gt;/tmp&lt;/code&gt; because I don&amp;rsquo;t want to keep for too long. You may also
dump it in &lt;code&gt;$HOME/.Trash&lt;/code&gt; if you are on a Mac.&lt;/p&gt;

&lt;p&gt;Just to make sure it all worked well, you might want to run the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;readr::read_csv(&amp;quot;/tmp/installed_packages.csv&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it worked, you will get a &lt;code&gt;data.frame&lt;/code&gt; with the same results from
&lt;code&gt;installed.packages()&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;steps-before-upgrading&#34;&gt;Steps before upgrading&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;If you use &lt;code&gt;RStudio&lt;/code&gt;, check that you are running the latest version: &lt;code&gt;Help -&amp;gt; Check for updates&lt;/code&gt;.
Install any updates if necessary.&lt;/li&gt;
&lt;li&gt;Download the latest &lt;code&gt;R&lt;/code&gt; installer for your OS: &lt;a href=&#34;https://cloud.r-project.org/&#34; target=&#34;_blank&#34;&gt;CRAN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;One final step is probably necessary to avoid immediate crashes after you upgrade. Run the following in &lt;code&gt;Terminal&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;if [ -f $HOME/.RData ]; then mv $HOME/.RData $HOME/.RData.bk; fi
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;p&gt;&lt;code&gt;$HOME/.RData&lt;/code&gt; can be a source of immediate crashes after an update.&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;&lt;code&gt;$HOME/.RData&lt;/code&gt; when it boots holds any information on
any sessions you may have run with your &lt;code&gt;$HOME&lt;/code&gt; as your working directory. When
starting up &lt;code&gt;R&lt;/code&gt;, it will usually try to load this file. If you are
like me, these sessions are often just used to test something out quickly, or some
through away code I am trying out from the internet. Now, if that session has any
libraries that have &lt;code&gt;C/C++&lt;/code&gt; code compiled with a previous version of &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;
will likely &lt;code&gt;segfault&lt;/code&gt; and quit.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34;&gt;
  &lt;p&gt;This issue is easier to diagnose if you run the
native &lt;code&gt;R&lt;/code&gt; app rather than &lt;code&gt;RStudio&lt;/code&gt;. In &lt;code&gt;RStudio&lt;/code&gt; you usually only get an unhelpful
message saying that &lt;code&gt;R&lt;/code&gt; has quit.&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;This is really only a problem because we are trying to be smart, and carry-over
our previous installation of libraries to the new &lt;code&gt;R&lt;/code&gt; installation via our
static &lt;code&gt;R&lt;/code&gt; library folder. If that did not exist, &lt;code&gt;R&lt;/code&gt; would simply fail to load
the library, and issue you with an error saying it could not find the library.
You would then re-install it, and thus you would have avoided this issue altogether.&lt;/p&gt;

&lt;h1 id=&#34;after-you-upgrade&#34;&gt;After you upgrade&lt;/h1&gt;

&lt;p&gt;So, you have installed the latest version of &lt;code&gt;RStudio&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;. If all went
well so far, you should see something like this in your console when you boot
up &lt;code&gt;RStudio&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;R version 3.4.0 (2017-04-21) -- &amp;quot;You Stupid Darkness&amp;quot;
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#39;license()&#39; or &#39;licence()&#39; for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type &#39;contributors()&#39; for more information and
&#39;citation()&#39; on how to cite R or R packages in publications.

Type &#39;demo()&#39; for some demos, &#39;help()&#39; for on-line help, or
&#39;help.start()&#39; for an HTML browser interface to help.
Type &#39;q()&#39; to quit R.

[Workspace loaded from ~/.RData]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;before-we-start-installing-upgrading-packages&#34;&gt;Before we start installing/upgrading packages&lt;/h2&gt;

&lt;h3 id=&#34;set-all-the-repositories-you-wish-to-search-for-libraries&#34;&gt;Set all the repositories you wish to search for libraries&lt;/h3&gt;

&lt;p&gt;The great majority of my packages are available on &lt;code&gt;CRAN&lt;/code&gt;. But, a handful
(for instance, the great &lt;a href=&#34;https://github.com/GuangchuangYu/ggtree&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;ggtree&lt;/code&gt;&lt;/a&gt;),
however, are in &lt;code&gt;Bioconductor&lt;/code&gt;. You may have other repositories you wish to
have &lt;code&gt;R&lt;/code&gt; automatically search for libraries too.&lt;/p&gt;

&lt;p&gt;However, by default, &lt;code&gt;R&lt;/code&gt; will only search in &lt;code&gt;CRAN&lt;/code&gt;. It does have other repositories
listed under &lt;code&gt;$R_HOME/etc/repositories&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## URL          is the base URL (see R-admin.texi)
## default      is whether this should be a default choice
## source, win.binary, mac.binary   indicate if the corresponding type is present
##
## BioC entries are version-specific, with %v getting expanded to the
## BioC version associated with the current R version.
## Also, %bm is substituted from the setting of getOption(&amp;quot;BioC_mirror&amp;quot;)
##
menu_name       URL     default source  win.binary      mac.binary
CRAN    CRAN    @CRAN@  TRUE    TRUE    TRUE    TRUE
BioCsoft        &amp;quot;BioC software&amp;quot; %bm/packages/%v/bioc    FALSE   TRUE    TRUE    TRUE
BioCann &amp;quot;BioC annotation&amp;quot;       %bm/packages/%v/data/annotation FALSE   TRUE    TRUE    TRUE
BioCexp &amp;quot;BioC experiment&amp;quot;       %bm/packages/%v/data/experiment FALSE   TRUE    TRUE    TRUE
BioCextra       &amp;quot;BioC extra&amp;quot;    %bm/packages/%v/extra   FALSE   TRUE    TRUE    TRUE
CRANextra       CRAN (extras)   https://www.stats.ox.ac.uk/pub/RWin     FALSE   TRUE    TRUE    TRUE
Omegahat        Omegahat        http://www.omegahat.net/R       FALSE   TRUE    FALSE   FALSE
R-Forge R-Forge https://R-Forge.R-project.org   FALSE   TRUE    TRUE    TRUE
rforge.net      rforge.net      https://www.rforge.net  FALSE   TRUE    TRUE    TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that &lt;code&gt;BioConductor&lt;/code&gt; is second on the list. So, to enable &lt;code&gt;R&lt;/code&gt; to automatically
search &lt;code&gt;CRAN&lt;/code&gt; and &lt;code&gt;BioConductor&lt;/code&gt; the the following command into the &lt;code&gt;R&lt;/code&gt; console:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;setRepositories(ind = c(1,2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I suggest you check the &lt;code&gt;setRepositories&lt;/code&gt; documentation if you want to know more.
But, essentially, the &lt;code&gt;ind&lt;/code&gt; parameter indicates the indices of the rows of the
&lt;code&gt;$R_HOME/etc/reporsitories&lt;/code&gt; file that contain the repositories you wish to
automatically search for libraries. The documentation describes how you can
provide your own list of repositories.&lt;/p&gt;

&lt;h3 id=&#34;check-that-your-rlibs-is-the-first-in-the-libpaths&#34;&gt;Check that your &lt;code&gt;RLibs&lt;/code&gt; is the first in the &lt;code&gt;libPaths&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Just issue the command &lt;code&gt;libPaths()&lt;/code&gt; on the &lt;code&gt;R&lt;/code&gt; console. If your &lt;code&gt;$HOME/Rlibs&lt;/code&gt;
is not the first on the list, go back up to top of this post, and read about
setting the &lt;code&gt;R_LIBS&lt;/code&gt; environmental variable.&lt;/p&gt;

&lt;h2 id=&#34;if-you-just-setup-your-rlibs-folder-1&#34;&gt;If you just setup your &lt;code&gt;RLibs&lt;/code&gt; folder&lt;/h2&gt;

&lt;p&gt;We will use that file we saved above to generate a list of packages. Take the
following steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Read in the table:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;package_table &amp;lt;- read.csv(&amp;quot;/tmp/installed_packages.csv&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;Note that here I used the &lt;code&gt;utils::read.csv&lt;/code&gt; function and not the &lt;code&gt;readr::read_csv&lt;/code&gt;
function. The reason is at this point you should not have an
installed copy of &lt;code&gt;readr&lt;/code&gt;&lt;/p&gt;

&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;Pull out the list of package names (the first column of &lt;code&gt;package_table&lt;/code&gt;):&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;package_names &amp;lt;- package_table[,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Install packages automatically:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(package_names)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is it! Sit back, and watch as &lt;code&gt;R&lt;/code&gt; does all the work for you.&lt;/p&gt;

&lt;h2 id=&#34;if-you-previously-had-an-rlibs-type-folder&#34;&gt;If you previously had an &lt;code&gt;RLibs&lt;/code&gt;-type folder&lt;/h2&gt;

&lt;p&gt;You are in easy territory then. You need to issue
the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;update.packages(ask = F, checkBuilt = T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ask= F&lt;/code&gt; option will refrain from asking you questions. The &lt;code&gt;checkBuilt = T&lt;/code&gt;
option is &lt;strong&gt;very important&lt;/strong&gt;. It is possible that you have the latest version of
a package but it was built with a previous version of &lt;code&gt;R&lt;/code&gt;. In those case, you
want to make sure the package get updated to one that is built with your
current version of &lt;code&gt;R&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;Here, you might want to go get a coffee and/or watch an episode of your
favourite show and/or read some blog posts online. Depending on how many
packages you have installed, it could take a non-trivial amount of time to &lt;br /&gt;
finish up.&lt;/p&gt;

&lt;/div&gt;


&lt;h2 id=&#34;one-last-step&#34;&gt;One last step&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Hopefully, it all went well, and everything has installed/updated, and you
are almost ready to go. Just one last thing. If you moved your &lt;code&gt;$HOME/.RData&lt;/code&gt; to
&lt;code&gt;$HOME/.RData.bk&lt;/code&gt;. Then shutdown &lt;code&gt;R&lt;/code&gt;, and type the following into the &lt;code&gt;Terminal&lt;/code&gt;
to get it back:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mv $HOME/.RData.bk $HOME/.RData
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, when you boot up &lt;code&gt;R&lt;/code&gt; from &lt;code&gt;$HOME&lt;/code&gt; you should have your session back, and
hopefully no &lt;code&gt;segfaults&lt;/code&gt;!&lt;/p&gt;

&lt;h1 id=&#34;the-end&#34;&gt;The end&lt;/h1&gt;

&lt;p&gt;That is it! Congratulations!! You have just upgraded to the latest version of &lt;code&gt;R&lt;/code&gt;
in a relatively painless way. Happy coding!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
