<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.20.2" />
  <meta name="author" content="Anders Gonçalves da Silva">
  <meta name="description" content="Data science with a side of genomics!">
  <meta name="keywords" content="Data Science, Genomics, R, Python, Machine Learning">

  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="/css/highlight.min.css">
    
  
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/academicons.min.css">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono">
  <link rel="stylesheet" href="/css/hugo-academic.css">
  

  <link rel="alternate" href="/index.xml" type="application/rss+xml" title="dsci&#39;nomics: data science with a side of genomics">
  <link rel="feed" href="/index.xml" type="application/rss+xml" title="dsci&#39;nomics: data science with a side of genomics">

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="/post/2017-05-10-taste-of-cwl-part2/">

  

  <title>A first taste of the common workflow language, part 2. | dsci&#39;nomics: data science with a side of genomics</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71" 
  data-responsejs='{ 
  "create": [
    { "prop": "width"
    , "prefix": "min-width- r src"
    , "lazy": true
    , "breakpoints": [1281,1025,961,641,481,320,0] }
  ]}'>

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/" 
        data-min-width-0="dsci&#39;nomics"
        data-min-width-481="dsci&#39;nomics: data sci &#43; genomics"
        data-min-width-641="dsci&#39;nomics: data science with a side of genomics">dsci&#39;nomics: data science with a side of genomics</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#publications_selected">
            
            <span>Publications</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#posts">
            
            <span>Posts</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#talks">
            
            <span>Talks</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#contact">
            
            <span>Contact</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  
  <div class="article-header">
    <img src="/img//logos/CWL_banner.svg" class="article-banner" itemprop="image">
    
  </div>
  

  <div class="article-container">
    <h1 itemprop="name">A first taste of the common workflow language, part 2.</h1>
    

<div class="article-metadata">

  <span class="article-date">
    <time datetime="2017-05-10 12:00:00 &#43;0000 UTC" itemprop="datePublished">
      Wed, May 10, 2017
    </time>
  </span>

  

  
  
  
  <span class="article-tags">
    <i class="fa fa-tags"></i>
    
    <a href="/tags/cwl">CWL</a
    >
    
  </span>
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=%2fpost%2f2017-05-10-taste-of-cwl-part2%2f"
         target="_blank">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=A%20first%20taste%20of%20the%20common%20workflow%20language%2c%20part%202.&amp;url=%2fpost%2f2017-05-10-taste-of-cwl-part2%2f"
         target="_blank">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fpost%2f2017-05-10-taste-of-cwl-part2%2f&amp;title=A%20first%20taste%20of%20the%20common%20workflow%20language%2c%20part%202."
         target="_blank">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=%2fpost%2f2017-05-10-taste-of-cwl-part2%2f&amp;title=A%20first%20taste%20of%20the%20common%20workflow%20language%2c%20part%202."
         target="_blank">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=A%20first%20taste%20of%20the%20common%20workflow%20language%2c%20part%202.&amp;body=%2fpost%2f2017-05-10-taste-of-cwl-part2%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>

    <div class="article-style" itemprop="articleBody">
      

<h1 id="welcome-back-to-part-2-of-my-cwl-series">Welcome back to part 2 of my CWL series</h1>

<p>In my previous <a href="/post/2017-05-07-taste-of-cwl-part1/" target="_blank">post</a>, I talked about some of things that got me excited about CWL, and
I introduced the <code>Command Line Tool Description</code>. Here, I will introduce the <code>Workflow Description</code>,
which uses the <code>Command Line Tool Description</code> as a building block. I will do this by continuing with my
limit of detection problem. I am focusing on the first step of that problem, which was producing
sub-sampled reads using Heng Li&rsquo;s <code>seqtk</code>. In particular, this workflow
will take an object that houses a pair of related FASTQ files,
randomly sub-sample the files to several different total number of reads, with
each total number of reads retained replicated several times.</p>

<h1 id="an-example-workflow-description">An example Workflow description</h1>

<p>As a quick recap, CWL provides specs for two kind of documents: <code>Command Line Tool Description</code>,
and the <code>Workflow Description</code>. As suggested by the name, <code>Command Line Tool Description</code> documents
describe how to build a command line with some <code>inputs</code>, and describes how to handle the <code>output</code>.
The <code>Workflow Description</code> describes the steps which connect <code>Command Line Tool Descriptions</code> in
order to go from some raw <code>inputs</code> to the final <code>outputs</code> of interest.</p>

<p>The <code>Workflow Description</code> follows a similar pattern to that of the <code>Command Line Tool Description</code>,
and is similarly readable, but in my example, it is perhaps a bit long. So, I&rsquo;ll break it down into parts,
and go over it step-by-step. I decided to go with this example in spite of
its length because it is a real example of CWL in use. At the end, I&rsquo;ll point towards the GitHub repo where you can get the whole code.</p>

<h2 id="the-general-outline">The general outline</h2>

<p>The <code>Workflow Description</code> has three main sections: <code>header</code> section, an <code>IO</code> section, and a
<code>steps</code> section. I&rsquo;ll go over each in turn.</p>

<h2 id="the-header">The header</h2>

<p>First, we start with the header information:</p>

<pre><code class="language-yaml">cwlVersion: v1.0
class: Workflow

requirements:
 - class: ScatterFeatureRequirement
 - class: InlineJavascriptRequirement
 - class: StepInputExpressionRequirement
 - $import: readPair.yml
</code></pre>

<p>The first two lines are self-explanatory. You have to specify the
 version of the spec, and that this document refers to a Workflow.</p>

<p>The <code>requirements</code> outline some additional information that is required
 to run the Workflow. Three of the listed requirements are provided by
 the spec: <code>ScatterFeatureRequirement</code>, <code>InlineJavascriptRequirement</code>, and
 <code>StepInputExpressionRequirement</code>. Their names already hint at what
 functionality they enable, but I&rsquo;ll address them individually when I
 get to the appropriate portion of the description. This is only a subset
 of the additional features you get out of the box. You can find the
 description to others <a href="http://www.commonwl.org/v1.0/Workflow.html#WorkflowStep" target="_blank">here</a>.</p>

<p>The last item in the requirements section imports a <code>readPair.yml</code> file.
 Because my workflow works on pairs of FASTQ files, I needed to
 create an object that kept the pairs of files together, and passed them
 along through the workflow.</p>

<div class="alert alert-info">
  <p>While I am specifying the <code>requirements</code> at the start of my <code>Workflow Description</code>,
 they can be specified at each step individually, or within the individual
 <code>Command Line Tool Descriptions</code>. So, there is plenty of flexibility here.
 I like to think of these as modules in <code>Python</code>, or libraries in <code>R</code>. They
 add functionality!</p>

</div>


<h2 id="my-custom-object-readpair-yml">My custom object: <code>readPair.yml</code></h2>

<p>Before we continue, I will digress and show you the <code>readPair.yml</code> file to
 demonstrate the creation of a custom <code>type</code> of input. The motivation to
 create one was bourne out of the necessity of keeping PE FASTQ files together
 while pushing them through the pipeline. It is an unfortunate standard, but
 it is the standard at the moment:</p>

<pre><code class="language-yaml">class: SchemaDefRequirement
types:
 - name: FilePair
   type: record
   fields:
     - name: forward
       type: File
     - name: reverse
       type: File
     - name: seed
       type: int[]
     - name: number
       type: int[]
     - name: rep
       type: int[]
     - name: seqid
       type: string
</code></pre>

<p>The <code>class</code> just tells CWL that what is coming next is the definition of
a new <code>schema</code> or <code>type</code> of object. The <code>types</code> field allows you to
specify more then one new object per file. For each new type, you
need to specify a <code>name</code>, a <code>type</code> (which is always <code>record</code> for now,
this may change in future versions of CWL),
and then the <code>fields</code> that are the individual components of the object.
Each field has a <code>name</code>, and
<code>type</code>, which are usually the base types (e.g., <code>int</code>, <code>string</code>, <code>array</code>).</p>

<p>Note that I am using some syntactic sugar here to define <code>int</code> arrays: <code>int[]</code>.
That notation can be used with any of the defined types. So, after defining
a <code>FilePair</code> type, I can use <code>FilePair[]</code> to specify an array of <code>FilePair</code>s.</p>

<p>In short, my <code>FilePair</code> object has two <code>File</code>s: <code>forward</code> and <code>reverse</code>; it has
an array of <code>int</code>s that set the seeds to be used with <code>seqtk sample</code>; it has
an array of <code>int</code>s that have the <code>number</code> of reads I want to save, an array
of <code>int</code>s for the <code>rep</code>lication number, and a <code>string</code> for the sequence ID.
This object describes all the information needed to process a single pair of isolates. Each
array is as long as the number of sub-samples I will produce for that pair. For example, if
I wanted two replicates each of 10,000 and 50,000 reads (a total of four sets of sub-sampled reads), the
relevant section of my input file would look like this:</p>

<pre><code class="language-yaml">     seed: [42, 52, 62, 72]
     number: [10000, 10000, 50000, 50000]
     rep: [1, 2, 1, 2]
</code></pre>

<p>So, one run of <code>seqtk sample</code> would use <code>seed</code> = 42; <code>number</code> = 10000, and <code>rep</code> = 1,
and so forth. This arrangement is what makes it possible for me to take advantage
of the <code>ScatterFeatureRequirement</code> requirement named in the header, which I will
discuss below.</p>

<div class="alert alert-success">
  <p>Before we move on, I would just like to acknowledge that inspiration for
my <code>readPair.yml</code> came from <a href="https://github.com/h3abionet/h3abionet16S" target="_blank">h3abionet16S analysis package</a>.
The project describes quite an extensive CWL flow to deal with 16S data, and
it a good place to get some examples and inspiration. And, of course, a CWL flow
for 16S data.</p>

</div>


<h2 id="the-io-section">The IO section</h2>

<p>The IO section is not formally called the IO section anywhere. I just
called it that because it specifies the <code>inputs</code> and <code>outputs</code> of the
overall workflow.</p>

<p>Below, is the IO section of my <code>seqtk sample PE</code> workflow.</p>

<pre><code class="language-yaml">inputs:
    forward: File
    reverse: File
    seqid: string
    seed: int[]
    number: int[]
    rep: int[]

outputs:
    resampled_fastq:
        type: &quot;readPair.yml#FilePair&quot;
        outputSource: collect_output/fastq_pair_out
</code></pre>

<p>As you can see, there are two parts. In the <code>inputs</code> section,
you specify all the inputs you will need to
start your workflow, or that will be needed during the workflow but
are not generated as part of one of the intermediary steps (e.g.,
the path to a DB you might use for an intermediary BLAST). The
elements of the <code>inputs</code> have the same name of the
elements in the in the <code>FilePair</code> object created in the
<code>readPair.yml</code> file. That is how you connect information in your input
file to the <code>Workflow</code>.</p>

<p>In the <code>outputs</code> section, we specify what the <code>Workflow</code> will
output. In this case, there is a single output, named <code>resampled_fastq</code>.
It is of type <code>FilePair</code>. Here, a special notation is used that
identifies the particular schema we want from the <code>readPair.yml</code> file
by using the <code>#</code>. A deeper explanation of this notation can be
found in the <a href="http://www.commonwl.org/v1.0/SchemaSalad.html" target="_blank"><code>Schema SALAD specification</code></a>
that underlies the whole object notation used in CWL.</p>

<p>Finally, we specify the <code>source</code> of the output with a notation
<code>step_name/step_output</code>. This output will come from the <code>collect_output</code>
step, specifically, the <code>fastq_pair_out</code> output from that step.</p>

<h2 id="the-steps-section">The steps section</h2>

<p>The <code>steps</code> section outlines the steps that need to be taken to
go from the <code>inputs</code> to the <code>outputs</code> specified in the IO section. In
my <code>seqtk PE sample</code> workflow, there are three steps: <code>subsample_1</code>,
<code>subsample_2</code>, and <code>collect_output</code>. Because <code>seqtk sample</code> only
takes one file at a time, we need to run <code>seqtk sample</code> twice, one
for each file in the pair, with the same <code>seed</code>. The first two
steps take care of sub-sampling the two files, the last step
collects the pairs of files, and rebuilds a <code>FilePair</code> object to
return. The reason I want to return a <code>FilePair</code> object from this workflow
is that this workflow is a sub-workflow of my larger limit of detection
workflow. The following step in that larger workflow is an assembly step,
which takes as input PE FASTQ files. Returning a <code>FilePair</code> object is therefore
convenient for the next step.</p>

<p>Because steps 1 and 2 are essentially the same, I&rsquo;ll present
both below, but only go over the first step.</p>

<pre><code class="language-yaml">steps:
    subsample_1:
        in:
            fastq: forward
            seed: seed
            number: number
            rep: rep
            seqid: seqid
            read_number:
                valueFrom: ${return 1;}
        scatter: [seed, number, rep]
        scatterMethod: dotproduct
        out: [seqtkout]
        run: seqtk_sample.cwl
    subsample_2:
        in:
            fastq: reverse
            seed: seed
            number: number
            rep: rep
            seqid: seqid
            read_number:
                valueFrom: ${return 2;}
        scatter: [seed, number, rep]
        scatterMethod: dotproduct
        out: [seqtkout]
        run: seqtk_sample.cwl
</code></pre>

<p>For each <code>step</code>, some keywords are necessary: <code>in</code>, <code>out</code>, and <code>run</code>.
The <code>run</code> key can take either the name of a file that
contains a <code>Command Line Tool Description</code>, the name of a file
with another <code>Workflow Description</code> (allowing you to nest workflows),
or you could specify what to run within the document
(i.e., I could just copy-paste the
<code>Command Line Tool Description</code> from the previous
<a href="/post/2017-05-07-taste-of-cwl-part1/" target="_blank">post</a> directly
here). This, however, is not desirable. By keeping the definitions
separate, I am free to use it in other workflows. Below, I&rsquo;ll give
a cool example where I run some custom JavaScript, and explicitly
provide the definition of what to run rather than naming a file.</p>

<p>The <code>in</code> and <code>out</code> sections define what goes in to the step, and
what comes out. As might be expected in a workflow, there is a lot of IO that
happens at different levels (e.g., at the step level, or at the workflow level,
or at the command line tool level). Getting the plumbing right
is crucial for your <code>Workflow</code> to work properly.</p>

<p>In the <code>in</code>, we use a series of <code>key</code>:<code>value</code> pairs. The <code>keys</code> are the values
expected by the tool being run in the current step. If you
look back at the previous
<a href="/post/2017-05-07-taste-of-cwl-part1/" target="_blank">post</a>
you will notice that the inputs for <code>seqtk_sample.cwl</code> are
named <code>fastq</code>, <code>seed</code>, <code>rep</code>, etc. Under <code>read_number</code> I
use the notation <code>${}</code> to write a very small JavaScript script
to return a default <code>int</code> value of <code>1</code>. In step 2, I use the same
artifice to return a default <code>int</code> value of <code>2</code>. These make the <code>R1</code> and
<code>R2</code> bit of the sub-sampled PE filenames. I can use the notation <code>${}</code> to
embedded JavaScript into my workflow because I added
the requirement <code>InlineJavascriptRequirement</code> to the header
section.</p>

<div class="alert alert-info">
  <p>By including the <code>InlineJavascriptRequirement</code> it is possible
to write JavaScript scripts using the <code>${}</code> notation.</p>

</div>


<p>The ability to take an input by using the keyword <code>valueFrom</code> is
possible because I included the <code>StepInputExpressionRequirement</code> in
the header section.</p>

<div class="alert alert-info">
  <p>The <code>StepInputExpressionRequirement</code> allows one to use the keyword
<code>valueFrom</code> to set default values or use JavaScript expressions to
change inputs depending on other runtime variables.</p>

</div>


<p>The <code>values</code> associated with each <code>key</code> either reference
the <code>inputs</code> to the workflow directly
(those defined in the IO section), or outputs from other steps.
When referencing outputs from other steps, we use the same notation
used in the overall <code>outputs</code> section of <code>step_name/step_output</code>.
An example of this is in the third and final step of this <code>Workflow</code>.
When using outputs from other steps as inputs, this creates a
dependency between the steps, and dictates in what order
steps can be carried-out. If you have worked with <code>make</code>, this will sound
familiar.</p>

<p>The first two steps also include the following lines:</p>

<pre><code class="language-yaml">        scatter: [seed, number, rep]
        scatterMethod: dotproduct
</code></pre>

<p>The <code>scatter</code> allows one to break up the input in to a number of
smaller jobs. In this case, I am specifying that
<code>seed</code>, <code>number</code>, and <code>rep</code> need to be combined to form individual
jobs. The <code>scatterMethod</code> specifies how we combine them.
In particular, the <code>dotproduct</code> method means that the first element of
each of those arrays are joined to make a job, then the second
element of each array are joined to make another job, and so on.
It is a prerequisite, therefore, that the arrays all be of the
same length. Other methods include <code>nested_crossproduct</code> and
<code>flat_crossproduct</code> - read more about
them <a href="http://www.commonwl.org/v1.0/Workflow.html#WorkflowStep" target="_blank">here</a>.
This is possible because I added the <code>ScatterFeatureRequirement</code> in
the header section.</p>

<div class="alert alert-info">
  <p>The <code>ScatterFeatureRequirement</code> gives you the ability to apply or map
a command over input arrays.</p>

</div>


<p>The third step (<code>collect_output</code>), provides two additional examples of
what is possible in CWL: (1) you can write the code for a step
directly into the <code>Workflow Description</code>; (2) there is a third class of
object called <code>ExpressionTool</code> that allows one to use JavaScript to
accomplish what is needed. This gives CWL great flexibility to
build some complex workflows!</p>

<pre><code class="language-yaml">    collect_output:
        run:
            class: ExpressionTool
            inputs:
                seq_1:
                    type:
                        type: array
                        items: File
                seq_2:
                    type:
                        type: array
                        items: File
                seqid: string
            outputs:
                fastq_pair_out: &quot;readPair.yml#FilePair&quot;
            expression: &gt;
                ${
                    var ret=[];
                    for (var i = 0; i &lt; inputs.seq_1.length; ++i) {
                        var tmp = {}
                        tmp['forward'] = inputs.seq_1[i];
                        tmp['reverse'] = inputs.seq_2[i];
                        tmp['seqid'] = inputs.seqid;
                        tmp['seed'] = [inputs.seed[i]];
                        tmp['number'] = [inputs.number[i]];
                        tmp['rep'] = [inputs.rep[i]];
                        ret.push(tmp);
                    }
                    return { 'fastq_pair_out' : ret }
                }
        in:
            seq_1: subsample_1/seqtkout
            seq_2: subsample_2/seqtkout
            seqid: seqid
            seed: seed
            number: number
            rep: rep
        out:
            [ fastq_pair_out ]
</code></pre>

<p>In this step, I use the <code>ExpressionTool</code> to collect the
outputs from steps 1 and 2 and build <code>FilePair</code> objects,
and generate an array of <code>FilePair</code> objects to be the final
output of this <code>Workflow</code>.</p>

<p>The principles from the previous steps apply here too. The one
gotcha of writing the step in this way, is that it can be a bit
confusing with all the <code>inputs</code> and <code>outputs</code>. I should also mention again
that this is probably not very desirable way of organising your code. If
you would like to reuse this <code>ExpressionTool</code> in other workflows, you would
be better off writing it out to a separate file, as we demonstrated in
steps 1 and 2 of this workflow.</p>

<p>There are two things I want to call attention to here. First, to how <code>array</code>s are specified:</p>

<pre><code class="language-yaml">                seq_1:
                    type:
                        type: array
                        items: File
</code></pre>

<p>If you follow all the input plumbing, you should figure out that
<code>seq_1</code> is the array of <code>Files</code> outputted by step 1. But,
remember that when writing the <code>inputs</code> section, we need to
specify the <code>type</code> of each input. Because the elements of an
<code>array</code> can be of many different types, we need to specify what
is the type of the elements of this particular <code>array</code>. Another way
of doing this would be to use the <code>File[]</code> notation. The reason for
this odd notation (i.e., repetition of <code>type</code>) is because <code>array</code>s
are represented internally as <code>{&quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &lt;T&gt;}</code>.</p>

<p>The second point I wish to make relates to how <code>ExpressionTool</code>s are
written. Note that there is <strong>no</strong> <code>baseCommand</code> keyword here, but rather the
<code>expression</code> key is used. I also used the standard <code>YAML</code> notation <code>expression: &gt;</code> to
indicate that the <code>value</code> for that <code>key</code> will span multiple lines, and new lines
should be ignored (if new lines were important, then I would use the <code>expression: |</code>
notation). The actual expression presented here just loops over the
arrays outputted by steps 1 and 2, and builds individual <code>FilePair</code> objects
for each of the sub-sampled pairs created at those steps.</p>

<h1 id="wrapping-up">Wrapping up&hellip;</h1>

<p>That is it! You now should have the basics to build your own
workflows in CWL. What you need are individual <code>Command Line Tool Description</code>s
or <code>ExpressionTools</code> that will form the building blocks for the steps of a workflow,
and then put them together using the <code>Workflow Description</code>. You can nest sub-workflows into larger workflows
by making individual steps in a workflow call other <code>Workflow Description</code>s.
The examples I have provided in these two posts are, for instance, only a small sub-workflow
of my larger limit of detection workflow. The full workflow code can
be found on my <code>GitHub</code> in the <a href="https://github.com/andersgs/cwl_flows" target="_blank">cwl_flows</a> repo (more
detailed documentation still to be added).</p>

<p>I would like to finish this post by thanking Michael Crusoe
(<a href="https://twitter.com/biocrusoe" target="_blank">@biocrusoe</a>) for help setting up some of this
workflow (check out my question and answers on <a href="https://www.biostars.org/p/245032/" target="_blank">BioStars</a>).
This highlighted the incredible support available to build CWL flows currently
available. I&rsquo;ll talk more about this in the next
post. In the meantime, I highly recommend checking out the
<a href="https://www.biostars.org/t/cwl/" target="_blank">BioStars</a> CWL tag if you
ever get stuck!</p>

<div class="alert alert-info">
  <p>You can get great support with your workflows through the
CWL tag on <a href="https://www.biostars.org/t/cwl/" target="_blank">BioStars</a></p>

</div>


    </div>
  </div>

</article>

<div class="container">
  <nav>
  <ul class="pager">
    
    <li class="previous"><a href="/post/2017-05-07-taste-of-cwl-part1/"><span
      aria-hidden="true">&larr;</span> A first taste of the common workflow language, part 1.</a></li>
    

    
  </ul>
</nav>

</div>

<div class="article-container">
  
<section id="comments">
  <div id="disqus_thread">
    <div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'dscinomics';
    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>
</section>


</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Anders Gonçalves da Silva &middot; 

      Powered by the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    <script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.4/TweenMax.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/gsap/latest/plugins/ScrollToPlugin.min.js"></script>
    <script src="/js/jquery-1.12.3.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/isotope.pkgd.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.1/imagesloaded.pkgd.min.js"></script>
    <script src="/js/hugo-academic.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js" charset="utf-8"></script>
    <script src="http://airve.github.com/js/response/response.min.js" charset="utf-8"></script>
    

    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-98372807-1', 'auto');
        ga('send', 'pageview');

         
        var links = document.querySelectorAll('a');
        Array.prototype.map.call(links, function(item) {
            if (item.host != document.location.host) {
                item.addEventListener('click', function() {
                    var action = item.getAttribute('data-action') || 'follow';
                    ga('send', 'event', 'outbound', action, item.href);
                });
            }
        });
    </script>
    

    
    
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>

      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/r.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/bash.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/javascript.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/stan.min.js"></script>
      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    <script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
    

  </body>
</html>

